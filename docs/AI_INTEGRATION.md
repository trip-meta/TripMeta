# TripMeta AIæœåŠ¡é›†æˆæŒ‡å—

## ğŸ“‹ ç›®å½•

- [AIæœåŠ¡æ¦‚è§ˆ](#aiæœåŠ¡æ¦‚è§ˆ)
- [GPTé›†æˆ](#gpté›†æˆ)
- [è¯­éŸ³æœåŠ¡é›†æˆ](#è¯­éŸ³æœåŠ¡é›†æˆ)
- [è®¡ç®—æœºè§†è§‰é›†æˆ](#è®¡ç®—æœºè§†è§‰é›†æˆ)
- [æ¨èç³»ç»Ÿ](#æ¨èç³»ç»Ÿ)
- [AIæœåŠ¡ç®¡ç†](#aiæœåŠ¡ç®¡ç†)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)

## ğŸ¤– AIæœåŠ¡æ¦‚è§ˆ

TripMetaé›†æˆäº†å¤šç§AIæœåŠ¡ï¼Œä¸ºç”¨æˆ·æä¾›æ™ºèƒ½åŒ–çš„VRæ—…æ¸¸ä½“éªŒï¼š

- **GPT-4**: æ™ºèƒ½å¯¹è¯å’Œå†…å®¹ç”Ÿæˆ
- **Azure Speech**: è¯­éŸ³è¯†åˆ«å’Œåˆæˆ
- **Computer Vision**: åœºæ™¯ç†è§£å’Œç‰©ä½“è¯†åˆ«
- **æ¨èå¼•æ“**: ä¸ªæ€§åŒ–å†…å®¹æ¨è
- **æƒ…æ„Ÿåˆ†æ**: ç”¨æˆ·æƒ…ç»ªè¯†åˆ«å’Œå“åº”

### AIæœåŠ¡æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AI Service Layer                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AI Service Manager                                     â”‚
â”‚  â”œâ”€â”€ Service Discovery    â”œâ”€â”€ Load Balancing           â”‚
â”‚  â”œâ”€â”€ Health Monitoring    â”œâ”€â”€ Failover Strategy        â”‚
â”‚  â”œâ”€â”€ Rate Limiting        â””â”€â”€ Circuit Breaker          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Core AI Services                                       â”‚
â”‚  â”œâ”€â”€ GPT Service          â”œâ”€â”€ Speech Service           â”‚
â”‚  â”‚   â”œâ”€â”€ Chat Completion  â”‚   â”œâ”€â”€ Speech Recognition   â”‚
â”‚  â”‚   â”œâ”€â”€ Text Generation  â”‚   â”œâ”€â”€ Speech Synthesis     â”‚
â”‚  â”‚   â”œâ”€â”€ Context Memory   â”‚   â”œâ”€â”€ Voice Cloning        â”‚
â”‚  â”‚   â””â”€â”€ Fine-tuning      â”‚   â””â”€â”€ Real-time STT/TTS    â”‚
â”‚  â”œâ”€â”€ Vision Service       â”œâ”€â”€ Recommendation Engine    â”‚
â”‚  â”‚   â”œâ”€â”€ Scene Analysis   â”‚   â”œâ”€â”€ Collaborative Filter â”‚
â”‚  â”‚   â”œâ”€â”€ Object Detection â”‚   â”œâ”€â”€ Content-based Filter â”‚
â”‚  â”‚   â”œâ”€â”€ OCR Processing   â”‚   â”œâ”€â”€ Deep Learning Model  â”‚
â”‚  â”‚   â””â”€â”€ Image Generation â”‚   â””â”€â”€ Real-time Inference  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AI Infrastructure                                      â”‚
â”‚  â”œâ”€â”€ Model Management     â”œâ”€â”€ Data Pipeline            â”‚
â”‚  â”‚   â”œâ”€â”€ Model Versioning â”‚   â”œâ”€â”€ Data Preprocessing   â”‚
â”‚  â”‚   â”œâ”€â”€ A/B Testing      â”‚   â”œâ”€â”€ Feature Engineering  â”‚
â”‚  â”‚   â”œâ”€â”€ Model Deployment â”‚   â”œâ”€â”€ Data Validation      â”‚
â”‚  â”‚   â””â”€â”€ Performance Mon. â”‚   â””â”€â”€ ETL Processes        â”‚
â”‚  â”œâ”€â”€ Caching Layer        â””â”€â”€ Security & Privacy       â”‚
â”‚  â”‚   â”œâ”€â”€ Response Cache   â”œâ”€â”€ Data Encryption          â”‚
â”‚  â”‚   â”œâ”€â”€ Model Cache      â”œâ”€â”€ PII Protection           â”‚
â”‚  â”‚   â”œâ”€â”€ Embedding Cache  â”œâ”€â”€ Audit Logging           â”‚
â”‚  â”‚   â””â”€â”€ Prediction Cache â””â”€â”€ Compliance Monitoring    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  GPTé›†æˆ

### GPTæœåŠ¡é…ç½®

```csharp
// GPTé…ç½®ç±»
[Serializable]
public class GPTConfiguration
{
    public string ApiKey { get; set; }
    public string BaseUrl { get; set; } = "https://api.openai.com/v1";
    public string Model { get; set; } = "gpt-4";
    public int MaxTokens { get; set; } = 2048;
    public float Temperature { get; set; } = 0.7f;
    public float TopP { get; set; } = 1.0f;
    public int MaxRetries { get; set; } = 3;
    public int TimeoutSeconds { get; set; } = 30;
    public bool EnableStreaming { get; set; } = true;
    public string SystemPrompt { get; set; }
}

// GPTæœåŠ¡å®ç°
public class GPTService : IGPTService, IDisposable
{
    private readonly GPTConfiguration _config;
    private readonly HttpClient _httpClient;
    private readonly ILogger _logger;
    private readonly IRateLimiter _rateLimiter;
    private readonly ICircuitBreaker _circuitBreaker;
    
    public GPTService(GPTConfiguration config, ILogger logger)
    {
        _config = config;
        _logger = logger;
        _httpClient = CreateHttpClient();
        _rateLimiter = new TokenBucketRateLimiter(60, TimeSpan.FromMinutes(1)); // 60 requests per minute
        _circuitBreaker = new CircuitBreaker(5, TimeSpan.FromMinutes(1)); // 5 failures, 1 minute timeout
    }
    
    public async Task<string> GenerateResponseAsync(string prompt, GPTOptions options = null)
    {
        await _rateLimiter.WaitAsync();
        
        return await _circuitBreaker.ExecuteAsync(async () =>
        {
            var request = CreateChatRequest(prompt, options);
            var response = await SendRequestAsync(request);
            
            _logger.LogInfo($"GPT response generated. Tokens used: {response.Usage.TotalTokens}");
            
            return response.Choices[0].Message.Content;
        });
    }
    
    public async IAsyncEnumerable<string> GenerateStreamAsync(string prompt, GPTOptions options = null)
    {
        await _rateLimiter.WaitAsync();
        
        var request = CreateChatRequest(prompt, options);
        request.Stream = true;
        
        using var response = await _httpClient.PostAsync("/chat/completions", 
            new StringContent(JsonSerializer.Serialize(request), Encoding.UTF8, "application/json"));
        
        using var stream = await response.Content.ReadAsStreamAsync();
        using var reader = new StreamReader(stream);
        
        string line;
        while ((line = await reader.ReadLineAsync()) != null)
        {
            if (line.StartsWith("data: "))
            {
                var data = line.Substring(6);
                if (data == "[DONE]") break;
                
                var chunk = JsonSerializer.Deserialize<GPTStreamChunk>(data);
                if (chunk.Choices?[0]?.Delta?.Content != null)
                {
                    yield return chunk.Choices[0].Delta.Content;
                }
            }
        }
    }
    
    private ChatCompletionRequest CreateChatRequest(string prompt, GPTOptions options)
    {
        var messages = new List<ChatMessage>();
        
        // æ·»åŠ ç³»ç»Ÿæç¤º
        if (!string.IsNullOrEmpty(_config.SystemPrompt))
        {
            messages.Add(new ChatMessage
            {
                Role = "system",
                Content = _config.SystemPrompt
            });
        }
        
        // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
        messages.Add(new ChatMessage
        {
            Role = "user",
            Content = prompt
        });
        
        return new ChatCompletionRequest
        {
            Model = options?.Model ?? _config.Model,
            Messages = messages,
            MaxTokens = options?.MaxTokens ?? _config.MaxTokens,
            Temperature = options?.Temperature ?? _config.Temperature,
            TopP = options?.TopP ?? _config.TopP,
            Stream = false
        };
    }
}
```

### ä¸Šä¸‹æ–‡ç®¡ç†

```csharp
// å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†
public class ConversationContextManager : IConversationContextManager
{
    private readonly Dictionary<string, ConversationContext> _contexts;
    private readonly int _maxContextLength;
    private readonly int _maxTokens;
    
    public ConversationContextManager(int maxContextLength = 10, int maxTokens = 4000)
    {
        _contexts = new Dictionary<string, ConversationContext>();
        _maxContextLength = maxContextLength;
        _maxTokens = maxTokens;
    }
    
    public void AddMessage(string sessionId, string role, string content)
    {
        if (!_contexts.TryGetValue(sessionId, out var context))
        {
            context = new ConversationContext();
            _contexts[sessionId] = context;
        }
        
        context.Messages.Add(new ChatMessage
        {
            Role = role,
            Content = content,
            Timestamp = DateTime.UtcNow
        });
        
        // é™åˆ¶ä¸Šä¸‹æ–‡é•¿åº¦
        TrimContext(context);
    }
    
    public List<ChatMessage> GetContext(string sessionId)
    {
        return _contexts.TryGetValue(sessionId, out var context) 
            ? context.Messages.ToList() 
            : new List<ChatMessage>();
    }
    
    private void TrimContext(ConversationContext context)
    {
        // æŒ‰æ¶ˆæ¯æ•°é‡é™åˆ¶
        while (context.Messages.Count > _maxContextLength)
        {
            context.Messages.RemoveAt(0);
        }
        
        // æŒ‰Tokenæ•°é‡é™åˆ¶
        var totalTokens = EstimateTokenCount(context.Messages);
        while (totalTokens > _maxTokens && context.Messages.Count > 1)
        {
            context.Messages.RemoveAt(0);
            totalTokens = EstimateTokenCount(context.Messages);
        }
    }
    
    private int EstimateTokenCount(List<ChatMessage> messages)
    {
        // ç®€å•çš„Tokenä¼°ç®—ï¼š1ä¸ªTokençº¦ç­‰äº4ä¸ªå­—ç¬¦
        return messages.Sum(m => m.Content.Length / 4);
    }
}
```

### æ™ºèƒ½æç¤ºå·¥ç¨‹

```csharp
// æç¤ºæ¨¡æ¿ç®¡ç†
public class PromptTemplateManager : IPromptTemplateManager
{
    private readonly Dictionary<string, PromptTemplate> _templates;
    
    public PromptTemplateManager()
    {
        _templates = new Dictionary<string, PromptTemplate>
        {
            ["tour_guide"] = new PromptTemplate
            {
                Name = "æ™ºèƒ½å¯¼æ¸¸",
                Template = @"ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è™šæ‹Ÿå¯¼æ¸¸ï¼Œåå«å°ç¾ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºç”¨æˆ·æä¾›æœ‰è¶£ã€å‡†ç¡®ã€ä¸ªæ€§åŒ–çš„æ—…æ¸¸ä¿¡æ¯ã€‚

å½“å‰åœºæ™¯ï¼š{scene_description}
ç”¨æˆ·ä½ç½®ï¼š{user_location}
ç”¨æˆ·å…´è¶£ï¼š{user_interests}
å¤©æ°”ä¿¡æ¯ï¼š{weather_info}

è¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œç”¨å‹å¥½ã€ä¸“ä¸šçš„è¯­è°ƒå›ç­”ç”¨æˆ·çš„é—®é¢˜ï¼š{user_question}

å›ç­”è¦æ±‚ï¼š
1. ä¿æŒå‹å¥½å’Œä¸“ä¸šçš„è¯­è°ƒ
2. æä¾›å‡†ç¡®çš„å†å²å’Œæ–‡åŒ–ä¿¡æ¯
3. æ ¹æ®ç”¨æˆ·å…´è¶£ä¸ªæ€§åŒ–å›ç­”
4. å¦‚æœæ¶‰åŠå®‰å…¨é—®é¢˜ï¼Œè¯·ç»™å‡ºé€‚å½“æé†’
5. å›ç­”é•¿åº¦æ§åˆ¶åœ¨200å­—ä»¥å†…",
                Parameters = new[] { "scene_description", "user_location", "user_interests", "weather_info", "user_question" }
            },
            
            ["content_generator"] = new PromptTemplate
            {
                Name = "å†…å®¹ç”Ÿæˆå™¨",
                Template = @"è¯·ä¸ºä»¥ä¸‹æ—…æ¸¸æ™¯ç‚¹ç”Ÿæˆå¸å¼•äººçš„ä»‹ç»å†…å®¹ï¼š

æ™¯ç‚¹åç§°ï¼š{attraction_name}
æ™¯ç‚¹ç±»å‹ï¼š{attraction_type}
å†å²èƒŒæ™¯ï¼š{historical_background}
ç‰¹è‰²äº®ç‚¹ï¼š{highlights}
ç›®æ ‡å—ä¼—ï¼š{target_audience}

ç”Ÿæˆè¦æ±‚ï¼š
1. å†…å®¹è¦ç”ŸåŠ¨æœ‰è¶£ï¼Œèƒ½å¤Ÿå¸å¼•æ¸¸å®¢
2. çªå‡ºæ™¯ç‚¹çš„ç‹¬ç‰¹æ€§å’Œä»·å€¼
3. åŒ…å«å®ç”¨çš„æ¸¸è§ˆå»ºè®®
4. è¯­è¨€è¦é€šä¿—æ˜“æ‡‚
5. å­—æ•°æ§åˆ¶åœ¨300-500å­—ä¹‹é—´",
                Parameters = new[] { "attraction_name", "attraction_type", "historical_background", "highlights", "target_audience" }
            }
        };
    }
    
    public string GeneratePrompt(string templateName, Dictionary<string, string> parameters)
    {
        if (!_templates.TryGetValue(templateName, out var template))
        {
            throw new ArgumentException($"Template '{templateName}' not found");
        }
        
        var prompt = template.Template;
        
        foreach (var param in template.Parameters)
        {
            var placeholder = $"{{{param}}}";
            var value = parameters.TryGetValue(param, out var paramValue) ? paramValue : "";
            prompt = prompt.Replace(placeholder, value);
        }
        
        return prompt;
    }
}

// åŠ¨æ€æç¤ºä¼˜åŒ–
public class PromptOptimizer : IPromptOptimizer
{
    private readonly IGPTService _gptService;
    private readonly IAnalyticsService _analytics;
    
    public async Task<string> OptimizePromptAsync(string originalPrompt, string expectedOutput, string actualOutput)
    {
        var optimizationPrompt = $@"
è¯·ä¼˜åŒ–ä»¥ä¸‹AIæç¤ºï¼Œä½¿å…¶èƒ½å¤Ÿç”Ÿæˆæ›´æ¥è¿‘æœŸæœ›è¾“å‡ºçš„ç»“æœï¼š

åŸå§‹æç¤ºï¼š
{originalPrompt}

æœŸæœ›è¾“å‡ºï¼š
{expectedOutput}

å®é™…è¾“å‡ºï¼š
{actualOutput}

è¯·æä¾›ä¼˜åŒ–åçš„æç¤ºï¼Œå¹¶è¯´æ˜ä¼˜åŒ–ç†ç”±ï¼š";

        var optimizedPrompt = await _gptService.GenerateResponseAsync(optimizationPrompt);
        
        // è®°å½•ä¼˜åŒ–å†å²
        await _analytics.TrackPromptOptimizationAsync(originalPrompt, optimizedPrompt, expectedOutput, actualOutput);
        
        return optimizedPrompt;
    }
}
```

## ğŸ¤ è¯­éŸ³æœåŠ¡é›†æˆ

### Azure SpeechæœåŠ¡

```csharp
// è¯­éŸ³æœåŠ¡é…ç½®
[Serializable]
public class SpeechConfiguration
{
    public string SubscriptionKey { get; set; }
    public string Region { get; set; } = "eastus";
    public string Language { get; set; } = "zh-CN";
    public string VoiceName { get; set; } = "zh-CN-XiaoxiaoNeural";
    public float SpeechRate { get; set; } = 1.0f;
    public float Pitch { get; set; } = 0.0f;
    public int SampleRate { get; set; } = 16000;
    public AudioFormat AudioFormat { get; set; } = AudioFormat.Wav;
}

// è¯­éŸ³æœåŠ¡å®ç°
public class AzureSpeechService : ISpeechService, IDisposable
{
    private readonly SpeechConfiguration _config;
    private readonly SpeechConfig _speechConfig;
    private readonly ILogger _logger;
    private SpeechRecognizer _recognizer;
    private SpeechSynthesizer _synthesizer;
    
    public AzureSpeechService(SpeechConfiguration config, ILogger logger)
    {
        _config = config;
        _logger = logger;
        
        _speechConfig = SpeechConfig.FromSubscription(config.SubscriptionKey, config.Region);
        _speechConfig.SpeechRecognitionLanguage = config.Language;
        _speechConfig.SpeechSynthesisVoiceName = config.VoiceName;
        
        InitializeServices();
    }
    
    public async Task<string> RecognizeSpeechAsync(AudioClip audioClip)
    {
        try
        {
            var audioData = ConvertAudioClipToWav(audioClip);
            
            using var audioInputStream = AudioInputStream.CreatePushStream();
            using var audioConfig = AudioConfig.FromStreamInput(audioInputStream);
            using var recognizer = new SpeechRecognizer(_speechConfig, audioConfig);
            
            // æ¨é€éŸ³é¢‘æ•°æ®
            audioInputStream.Write(audioData);
            audioInputStream.Close();
            
            var result = await recognizer.RecognizeOnceAsync();
            
            if (result.Reason == ResultReason.RecognizedSpeech)
            {
                _logger.LogInfo($"Speech recognized: {result.Text}");
                return result.Text;
            }
            else if (result.Reason == ResultReason.NoMatch)
            {
                _logger.LogWarning("No speech could be recognized");
                return string.Empty;
            }
            else
            {
                _logger.LogError($"Speech recognition failed: {result.Reason}");
                return string.Empty;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Speech recognition error: {ex.Message}");
            throw;
        }
    }
    
    public async Task<AudioClip> SynthesizeSpeechAsync(string text, VoiceSettings voiceSettings = null)
    {
        try
        {
            var ssml = GenerateSSML(text, voiceSettings);
            
            using var synthesizer = new SpeechSynthesizer(_speechConfig);
            var result = await synthesizer.SpeakSsmlAsync(ssml);
            
            if (result.Reason == ResultReason.SynthesizingAudioCompleted)
            {
                var audioClip = ConvertWavToAudioClip(result.AudioData);
                _logger.LogInfo($"Speech synthesized successfully. Duration: {audioClip.length}s");
                return audioClip;
            }
            else
            {
                _logger.LogError($"Speech synthesis failed: {result.Reason}");
                return null;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Speech synthesis error: {ex.Message}");
            throw;
        }
    }
    
    public async IAsyncEnumerable<string> StartContinuousRecognitionAsync()
    {
        var recognitionQueue = new ConcurrentQueue<string>();
        var recognitionComplete = new TaskCompletionSource<bool>();
        
        _recognizer.Recognized += (sender, e) =>
        {
            if (e.Result.Reason == ResultReason.RecognizedSpeech)
            {
                recognitionQueue.Enqueue(e.Result.Text);
            }
        };
        
        _recognizer.SessionStopped += (sender, e) =>
        {
            recognitionComplete.SetResult(true);
        };
        
        await _recognizer.StartContinuousRecognitionAsync();
        
        while (!recognitionComplete.Task.IsCompleted)
        {
            if (recognitionQueue.TryDequeue(out var recognizedText))
            {
                yield return recognizedText;
            }
            
            await Task.Delay(100); // é¿å…CPUå ç”¨è¿‡é«˜
        }
        
        await _recognizer.StopContinuousRecognitionAsync();
    }
    
    private string GenerateSSML(string text, VoiceSettings voiceSettings)
    {
        var settings = voiceSettings ?? new VoiceSettings();
        
        return $@"
<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='{_config.Language}'>
    <voice name='{settings.VoiceName ?? _config.VoiceName}'>
        <prosody rate='{settings.Rate ?? _config.SpeechRate}' pitch='{settings.Pitch ?? _config.Pitch}'>
            {System.Security.SecurityElement.Escape(text)}
        </prosody>
    </voice>
</speak>";
    }
}
```

### å®æ—¶è¯­éŸ³å¤„ç†

```csharp
// å®æ—¶è¯­éŸ³å¤„ç†å™¨
public class RealTimeSpeechProcessor : MonoBehaviour
{
    [SerializeField] private float _silenceThreshold = 0.01f;
    [SerializeField] private float _silenceDuration = 2.0f;
    [SerializeField] private int _sampleRate = 16000;
    
    private AudioSource _audioSource;
    private ISpeechService _speechService;
    private bool _isRecording;
    private float _lastSoundTime;
    private List<float> _audioBuffer;
    
    public event Action<string> OnSpeechRecognized;
    public event Action OnRecordingStarted;
    public event Action OnRecordingStopped;
    
    private void Start()
    {
        _audioSource = GetComponent<AudioSource>();
        _speechService = ServiceContainer.Instance.GetService<ISpeechService>();
        _audioBuffer = new List<float>();
        
        StartListening();
    }
    
    public void StartListening()
    {
        if (!Microphone.IsRecording(null))
        {
            _audioSource.clip = Microphone.Start(null, true, 10, _sampleRate);
            _audioSource.loop = true;
            
            while (!(Microphone.GetPosition(null) > 0)) { }
            
            _audioSource.Play();
            _isRecording = true;
            
            StartCoroutine(ProcessAudioStream());
        }
    }
    
    public void StopListening()
    {
        if (Microphone.IsRecording(null))
        {
            Microphone.End(null);
            _audioSource.Stop();
            _isRecording = false;
        }
    }
    
    private IEnumerator ProcessAudioStream()
    {
        var samples = new float[1024];
        var lastPosition = 0;
        
        while (_isRecording)
        {
            var currentPosition = Microphone.GetPosition(null);
            
            if (currentPosition < lastPosition)
            {
                // å¤„ç†ç¯å½¢ç¼“å†²åŒºçš„å›ç»•
                var samplesToEnd = _audioSource.clip.samples - lastPosition;
                _audioSource.clip.GetData(samples, lastPosition);
                ProcessAudioSamples(samples, samplesToEnd);
                
                lastPosition = 0;
            }
            
            if (currentPosition > lastPosition)
            {
                var sampleCount = currentPosition - lastPosition;
                _audioSource.clip.GetData(samples, lastPosition);
                ProcessAudioSamples(samples, sampleCount);
                
                lastPosition = currentPosition;
            }
            
            yield return null;
        }
    }
    
    private void ProcessAudioSamples(float[] samples, int sampleCount)
    {
        var hasSound = false;
        
        for (int i = 0; i < sampleCount; i++)
        {
            var sample = Mathf.Abs(samples[i]);
            _audioBuffer.Add(samples[i]);
            
            if (sample > _silenceThreshold)
            {
                hasSound = true;
                _lastSoundTime = Time.time;
            }
        }
        
        if (hasSound && !_isRecording)
        {
            OnRecordingStarted?.Invoke();
            _isRecording = true;
        }
        else if (_isRecording && Time.time - _lastSoundTime > _silenceDuration)
        {
            ProcessRecordedAudio();
        }
    }
    
    private async void ProcessRecordedAudio()
    {
        OnRecordingStopped?.Invoke();
        
        if (_audioBuffer.Count > 0)
        {
            var audioClip = CreateAudioClipFromBuffer();
            var recognizedText = await _speechService.RecognizeSpeechAsync(audioClip);
            
            if (!string.IsNullOrEmpty(recognizedText))
            {
                OnSpeechRecognized?.Invoke(recognizedText);
            }
        }
        
        _audioBuffer.Clear();
        _isRecording = false;
    }
    
    private AudioClip CreateAudioClipFromBuffer()
    {
        var audioClip = AudioClip.Create("RecordedAudio", _audioBuffer.Count, 1, _sampleRate, false);
        audioClip.SetData(_audioBuffer.ToArray(), 0);
        return audioClip;
    }
}
```

## ğŸ‘ï¸ è®¡ç®—æœºè§†è§‰é›†æˆ

### Azure Computer Vision

```csharp
// è®¡ç®—æœºè§†è§‰æœåŠ¡
public class AzureVisionService : IVisionService
{
    private readonly string _subscriptionKey;
    private readonly string _endpoint;
    private readonly HttpClient _httpClient;
    private readonly ILogger _logger;
    
    public AzureVisionService(string subscriptionKey, string endpoint, ILogger logger)
    {
        _subscriptionKey = subscriptionKey;
        _endpoint = endpoint;
        _logger = logger;
        
        _httpClient = new HttpClient();
        _httpClient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);
    }
    
    public async Task<VisionAnalysisResult> AnalyzeImageAsync(Texture2D image, VisionFeatures features = VisionFeatures.All)
    {
        try
        {
            var imageBytes = image.EncodeToPNG();
            var content = new ByteArrayContent(imageBytes);
            content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
            
            var featuresParam = BuildFeaturesParameter(features);
            var url = $"{_endpoint}/vision/v3.2/analyze?visualFeatures={featuresParam}";
            
            var response = await _httpClient.PostAsync(url, content);
            var responseJson = await response.Content.ReadAsStringAsync();
            
            if (response.IsSuccessStatusCode)
            {
                var result = JsonSerializer.Deserialize<AzureVisionResponse>(responseJson);
                return ConvertToVisionResult(result);
            }
            else
            {
                _logger.LogError($"Vision API error: {response.StatusCode} - {responseJson}");
                return new VisionAnalysisResult { Success = false, ErrorMessage = responseJson };
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Vision analysis error: {ex.Message}");
            return new VisionAnalysisResult { Success = false, ErrorMessage = ex.Message };
        }
    }
    
    public async Task<List<DetectedObject>> DetectObjectsAsync(Texture2D image)
    {
        try
        {
            var imageBytes = image.EncodeToPNG();
            var content = new ByteArrayContent(imageBytes);
            content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
            
            var url = $"{_endpoint}/vision/v3.2/detect";
            var response = await _httpClient.PostAsync(url, content);
            var responseJson = await response.Content.ReadAsStringAsync();
            
            if (response.IsSuccessStatusCode)
            {
                var result = JsonSerializer.Deserialize<ObjectDetectionResponse>(responseJson);
                return result.Objects.Select(obj => new DetectedObject
                {
                    Name = obj.ObjectProperty,
                    Confidence = obj.Confidence,
                    BoundingBox = new BoundingBox
                    {
                        X = obj.Rectangle.X,
                        Y = obj.Rectangle.Y,
                        Width = obj.Rectangle.W,
                        Height = obj.Rectangle.H
                    }
                }).ToList();
            }
            else
            {
                _logger.LogError($"Object detection error: {response.StatusCode} - {responseJson}");
                return new List<DetectedObject>();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Object detection error: {ex.Message}");
            return new List<DetectedObject>();
        }
    }
    
    public async Task<string> GenerateImageDescriptionAsync(Texture2D image, string language = "zh")
    {
        try
        {
            var imageBytes = image.EncodeToPNG();
            var content = new ByteArrayContent(imageBytes);
            content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
            
            var url = $"{_endpoint}/vision/v3.2/describe?maxCandidates=1&language={language}";
            var response = await _httpClient.PostAsync(url, content);
            var responseJson = await response.Content.ReadAsStringAsync();
            
            if (response.IsSuccessStatusCode)
            {
                var result = JsonSerializer.Deserialize<ImageDescriptionResponse>(responseJson);
                return result.Description.Captions.FirstOrDefault()?.Text ?? "æ— æ³•ç”Ÿæˆæè¿°";
            }
            else
            {
                _logger.LogError($"Image description error: {response.StatusCode} - {responseJson}");
                return "æè¿°ç”Ÿæˆå¤±è´¥";
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Image description error: {ex.Message}");
            return "æè¿°ç”Ÿæˆå¼‚å¸¸";
        }
    }
}
```

### åœºæ™¯ç†è§£ç³»ç»Ÿ

```csharp
// åœºæ™¯ç†è§£æœåŠ¡
public class SceneUnderstandingService : ISceneUnderstandingService
{
    private readonly IVisionService _visionService;
    private readonly IGPTService _gptService;
    private readonly ILogger _logger;
    
    public async Task<SceneAnalysis> AnalyzeSceneAsync(Texture2D sceneImage, Vector3 userPosition, Vector3 userDirection)
    {
        var analysis = new SceneAnalysis
        {
            Timestamp = DateTime.UtcNow,
            UserPosition = userPosition,
            UserDirection = userDirection
        };
        
        try
        {
            // 1. åŸºç¡€è§†è§‰åˆ†æ
            var visionResult = await _visionService.AnalyzeImageAsync(sceneImage, 
                VisionFeatures.Objects | VisionFeatures.Categories | VisionFeatures.Description);
            
            analysis.DetectedObjects = visionResult.Objects;
            analysis.Categories = visionResult.Categories;
            analysis.Description = visionResult.Description;
            
            // 2. æ·±åº¦åœºæ™¯ç†è§£
            var contextPrompt = GenerateSceneContextPrompt(visionResult);
            var sceneContext = await _gptService.GenerateResponseAsync(contextPrompt);
            analysis.ContextualDescription = sceneContext;
            
            // 3. å…´è¶£ç‚¹è¯†åˆ«
            analysis.PointsOfInterest = await IdentifyPointsOfInterestAsync(visionResult, userPosition);
            
            // 4. å¯¼èˆªå»ºè®®
            analysis.NavigationSuggestions = await GenerateNavigationSuggestionsAsync(analysis);
            
            // 5. å®‰å…¨è¯„ä¼°
            analysis.SafetyAssessment = await AssessSceneSafetyAsync(visionResult);
            
            return analysis;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Scene analysis error: {ex.Message}");
            analysis.ErrorMessage = ex.Message;
            return analysis;
        }
    }
    
    private string GenerateSceneContextPrompt(VisionAnalysisResult visionResult)
    {
        var objectList = string.Join(", ", visionResult.Objects.Select(o => o.Name));
        var categories = string.Join(", ", visionResult.Categories.Select(c => c.Name));
        
        return $@"
åŸºäºä»¥ä¸‹è§†è§‰åˆ†æç»“æœï¼Œè¯·æä¾›è¯¦ç»†çš„åœºæ™¯ç†è§£å’Œæ—…æ¸¸å¯¼è§ˆä¿¡æ¯ï¼š

åœºæ™¯æè¿°ï¼š{visionResult.Description}
æ£€æµ‹åˆ°çš„ç‰©ä½“ï¼š{objectList}
åœºæ™¯åˆ†ç±»ï¼š{categories}

è¯·æä¾›ï¼š
1. åœºæ™¯çš„å†å²æ–‡åŒ–èƒŒæ™¯
2. ä¸»è¦çœ‹ç‚¹å’Œç‰¹è‰²
3. æœ€ä½³è§‚èµè§’åº¦å’Œæ—¶é—´
4. ç›¸å…³çš„æœ‰è¶£æ•…äº‹æˆ–ä¼ è¯´
5. æ‘„å½±å»ºè®®

å›ç­”è¦ä¸“ä¸šä¸”æœ‰è¶£ï¼Œé€‚åˆä½œä¸ºè™šæ‹Ÿå¯¼æ¸¸çš„è§£è¯´å†…å®¹ã€‚";
    }
    
    private async Task<List<PointOfInterest>> IdentifyPointsOfInterestAsync(VisionAnalysisResult visionResult, Vector3 userPosition)
    {
        var pointsOfInterest = new List<PointOfInterest>();
        
        foreach (var obj in visionResult.Objects.Where(o => o.Confidence > 0.7))
        {
            var poi = new PointOfInterest
            {
                Name = obj.Name,
                Position = EstimateWorldPosition(obj.BoundingBox, userPosition),
                Confidence = obj.Confidence,
                Type = ClassifyObjectType(obj.Name),
                Description = await GenerateObjectDescriptionAsync(obj.Name)
            };
            
            pointsOfInterest.Add(poi);
        }
        
        return pointsOfInterest;
    }
    
    private Vector3 EstimateWorldPosition(BoundingBox boundingBox, Vector3 userPosition)
    {
        // ç®€åŒ–çš„3Dä½ç½®ä¼°ç®—ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        var screenCenter = new Vector2(boundingBox.X + boundingBox.Width / 2, boundingBox.Y + boundingBox.Height / 2);
        var worldDirection = Camera.main.ScreenToWorldPoint(new Vector3(screenCenter.x, screenCenter.y, 10f));
        
        return userPosition + worldDirection.normalized * 5f; // å‡è®¾è·ç¦»5ç±³
    }
}
```

## ğŸ¯ æ¨èç³»ç»Ÿ

### ååŒè¿‡æ»¤æ¨è

```csharp
// æ¨èå¼•æ“
public class RecommendationEngine : IRecommendationEngine
{
    private readonly IUserBehaviorService _behaviorService;
    private readonly IContentService _contentService;
    private readonly IMLModelService _mlService;
    private readonly ILogger _logger;
    
    public async Task<List<Recommendation>> GetRecommendationsAsync(string userId, RecommendationContext context)
    {
        try
        {
            var userProfile = await BuildUserProfileAsync(userId);
            var candidates = await GetCandidateItemsAsync(context);
            
            var recommendations = new List<Recommendation>();
            
            // 1. ååŒè¿‡æ»¤æ¨è
            var collaborativeRecs = await GetCollaborativeRecommendationsAsync(userProfile, candidates);
            recommendations.AddRange(collaborativeRecs);
            
            // 2. åŸºäºå†…å®¹çš„æ¨è
            var contentBasedRecs = await GetContentBasedRecommendationsAsync(userProfile, candidates);
            recommendations.AddRange(contentBasedRecs);
            
            // 3. æ·±åº¦å­¦ä¹ æ¨è
            var deepLearningRecs = await GetDeepLearningRecommendationsAsync(userProfile, candidates, context);
            recommendations.AddRange(deepLearningRecs);
            
            // 4. æ··åˆæ¨èå’Œæ’åº
            var finalRecommendations = await HybridRankingAsync(recommendations, userProfile, context);
            
            return finalRecommendations.Take(10).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError($"Recommendation generation error: {ex.Message}");
            return new List<Recommendation>();
        }
    }
    
    private async Task<UserProfile> BuildUserProfileAsync(string userId)
    {
        var behaviors = await _behaviorService.GetUserBehaviorsAsync(userId);
        var preferences = ExtractPreferences(behaviors);
        
        return new UserProfile
        {
            UserId = userId,
            Preferences = preferences,
            VisitHistory = behaviors.Where(b => b.Type == BehaviorType.Visit).ToList(),
            Ratings = behaviors.Where(b => b.Type == BehaviorType.Rating).ToList(),
            Demographics = await GetUserDemographicsAsync(userId)
        };
    }
    
    private async Task<List<Recommendation>> GetCollaborativeRecommendationsAsync(UserProfile userProfile, List<ContentItem> candidates)
    {
        // ç”¨æˆ·-ç‰©å“ååŒè¿‡æ»¤
        var similarUsers = await FindSimilarUsersAsync(userProfile);
        var recommendations = new List<Recommendation>();
        
        foreach (var candidate in candidates)
        {
            var score = CalculateCollaborativeScore(candidate, similarUsers);
            if (score > 0.5) // é˜ˆå€¼è¿‡æ»¤
            {
                recommendations.Add(new Recommendation
                {
                    ItemId = candidate.Id,
                    Score = score,
                    Reason = "åŸºäºç›¸ä¼¼ç”¨æˆ·çš„å–œå¥½æ¨è",
                    Algorithm = "CollaborativeFiltering"
                });
            }
        }
        
        return recommendations;
    }
    
    private async Task<List<Recommendation>> GetContentBasedRecommendationsAsync(UserProfile userProfile, List<ContentItem> candidates)
    {
        var recommendations = new List<Recommendation>();
        
        foreach (var candidate in candidates)
        {
            var score = CalculateContentSimilarity(candidate, userProfile.Preferences);
            if (score > 0.6)
            {
                recommendations.Add(new Recommendation
                {
                    ItemId = candidate.Id,
                    Score = score,
                    Reason = $"å› ä¸ºæ‚¨å–œæ¬¢{GetTopPreference(userProfile.Preferences)}",
                    Algorithm = "ContentBased"
                });
            }
        }
        
        return recommendations;
    }
    
    private async Task<List<Recommendation>> GetDeepLearningRecommendationsAsync(UserProfile userProfile, List<ContentItem> candidates, RecommendationContext context)
    {
        // ä½¿ç”¨æ·±åº¦å­¦ä¹ æ¨¡å‹è¿›è¡Œæ¨è
        var features = BuildFeatureVector(userProfile, context);
        var predictions = await _mlService.PredictAsync("recommendation_model", features);
        
        var recommendations = new List<Recommendation>();
        
        for (int i = 0; i < candidates.Count && i < predictions.Length; i++)
        {
            if (predictions[i] > 0.7)
            {
                recommendations.Add(new Recommendation
                {
                    ItemId = candidates[i].Id,
                    Score = predictions[i],
                    Reason = "AIæ™ºèƒ½æ¨è",
                    Algorithm = "DeepLearning"
                });
            }
        }
        
        return recommendations;
    }
    
    private async Task<List<Recommendation>> HybridRankingAsync(List<Recommendation> recommendations, UserProfile userProfile, RecommendationContext context)
    {
        // æ··åˆæ¨èç®—æ³•æƒé‡
        var weights = new Dictionary<string, float>
        {
            ["CollaborativeFiltering"] = 0.4f,
            ["ContentBased"] = 0.3f,
            ["DeepLearning"] = 0.3f
        };
        
        // æŒ‰ç®—æ³•åˆ†ç»„å¹¶è®¡ç®—åŠ æƒåˆ†æ•°
        var groupedRecs = recommendations.GroupBy(r => r.ItemId);
        var hybridRecommendations = new List<Recommendation>();
        
        foreach (var group in groupedRecs)
        {
            var weightedScore = group.Sum(r => r.Score * weights.GetValueOrDefault(r.Algorithm, 0.1f));
            var bestRec = group.OrderByDescending(r => r.Score).First();
            
            bestRec.Score = weightedScore;
            bestRec.Algorithm = "Hybrid";
            
            hybridRecommendations.Add(bestRec);
        }
        
        // è€ƒè™‘ä¸Šä¸‹æ–‡å› ç´ è°ƒæ•´æ’åº
        foreach (var rec in hybridRecommendations)
        {
            rec.Score *= CalculateContextualBoost(rec, context);
        }
        
        return hybridRecommendations.OrderByDescending(r => r.Score).ToList();
    }
}
```

## ğŸ”§ AIæœåŠ¡ç®¡ç†

### æœåŠ¡å¥åº·ç›‘æ§

```csharp
// AIæœåŠ¡å¥åº·ç›‘æ§
public class AIServiceHealthMonitor : MonoBehaviour
{
    [SerializeField] private float _checkInterval = 30f;
    [SerializeField] private int _maxFailures = 3;
    
    private readonly Dictionary<string, ServiceHealthStatus> _serviceStatus;
    private readonly Dictionary<string, int> _failureCounts;
    
    public event Action<string, ServiceHealthStatus> OnServiceStatusChanged;
    
    private void Start()
    {
        _serviceStatus = new Dictionary<string, ServiceHealthStatus>();
        _failureCounts = new Dictionary<string, int>();
        
        InvokeRepeating(nameof(CheckAllServices), 0f, _checkInterval);
    }
    
    private async void CheckAllServices()
    {
        var services = new[]
        {
            "GPTService",
            "SpeechService", 
            "VisionService",
            "RecommendationEngine"
        };
        
        foreach (var serviceName in services)
        {
            await CheckServiceHealthAsync(serviceName);
        }
    }
    
    private async Task CheckServiceHealthAsync(string serviceName)
    {
        try
        {
            var service = ServiceContainer.Instance.GetService<IHealthCheckable>(serviceName);
            var healthResult = await service.CheckHealthAsync();
            
            var previousStatus = _serviceStatus.GetValueOrDefault(serviceName, ServiceHealthStatus.Unknown);
            var currentStatus = healthResult.IsHealthy ? ServiceHealthStatus.Healthy : ServiceHealthStatus.Unhealthy;
            
            if (currentStatus != previousStatus)
            {
                _serviceStatus[serviceName] = currentStatus;
                OnServiceStatusChanged?.Invoke(serviceName, currentStatus);
                
                if (currentStatus == ServiceHealthStatus.Healthy)
                {
                    _failureCounts[serviceName] = 0;
                    Debug.Log($"Service {serviceName} is now healthy");
                }
                else
                {
                    _failureCounts[serviceName] = _failureCounts.GetValueOrDefault(serviceName, 0) + 1;
                    Debug.LogWarning($"Service {serviceName} is unhealthy: {healthResult.ErrorMessage}");
                    
                    if (_failureCounts[serviceName] >= _maxFailures)
                    {
                        await HandleServiceFailureAsync(serviceName);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"Health check failed for {serviceName}: {ex.Message}");
            _serviceStatus[serviceName] = ServiceHealthStatus.Error;
            OnServiceStatusChanged?.Invoke(serviceName, ServiceHealthStatus.Error);
        }
    }
    
    private async Task HandleServiceFailureAsync(string serviceName)
    {
        Debug.LogError($"Service {serviceName} has failed {_maxFailures} times. Attempting recovery...");
        
        try
        {
            // å°è¯•é‡å¯æœåŠ¡
            var service = ServiceContainer.Instance.GetService<IRestartable>(serviceName);
            await service.RestartAsync();
            
            Debug.Log($"Service {serviceName} restart attempted");
        }
        catch (Exception ex)
        {
            Debug.LogError($"Failed to restart service {serviceName}: {ex.Message}");
            
            // å¯ç”¨é™çº§æ¨¡å¼
            EnableFallbackMode(serviceName);
        }
    }
    
    private void EnableFallbackMode(string serviceName)
    {
        switch (serviceName)
        {
            case "GPTService":
                // ä½¿ç”¨æœ¬åœ°ç¼“å­˜çš„å›ç­”æˆ–ç®€åŒ–å›å¤
                EnableGPTFallback();
                break;
            case "SpeechService":
                // ä½¿ç”¨æ–‡æœ¬æ˜¾ç¤ºæ›¿ä»£è¯­éŸ³
                EnableSpeechFallback();
                break;
            case "VisionService":
                // ç¦ç”¨è§†è§‰åˆ†æåŠŸèƒ½
                EnableVisionFallback();
                break;
        }
        
        Debug.Log($"Fallback mode enabled for {serviceName}");
    }
}
```

### æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜

```csharp
// AIå“åº”ç¼“å­˜ç³»ç»Ÿ
public class AIResponseCache : IAIResponseCache
{
    private readonly IMemoryCache _memoryCache;
    private readonly IDistributedCache _distributedCache;
    private readonly ILogger _logger;
    
    public async Task<T> GetOrCreateAsync<T>(string key, Func<Task<T>> factory, TimeSpan? expiration = null)
    {
        // 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
        if (_memoryCache.TryGetValue(key, out T cachedValue))
        {
            return cachedValue;
        }
        
        // 2. æ£€æŸ¥åˆ†å¸ƒå¼ç¼“å­˜
        var distributedValue = await _distributedCache.GetAsync<T>(key);
        if (distributedValue != null)
        {
            // å›å¡«å†…å­˜ç¼“å­˜
            _memoryCache.Set(key, distributedValue, TimeSpan.FromMinutes(5));
            return distributedValue;
        }
        
        // 3. æ‰§è¡ŒåŸå§‹æ“ä½œ
        var result = await factory();
        
        // 4. ç¼“å­˜ç»“æœ
        var cacheExpiration = expiration ?? TimeSpan.FromHours(1);
        _memoryCache.Set(key, result, TimeSpan.FromMinutes(5));
        await _distributedCache.SetAsync(key, result, cacheExpiration);
        
        return result;
    }
    
    public string GenerateCacheKey(string operation, params object[] parameters)
    {
        var keyBuilder = new StringBuilder(operation);
        
        foreach (var param in parameters)
        {
            keyBuilder.Append(":");
            keyBuilder.Append(param?.ToString() ?? "null");
        }
        
        // ç”Ÿæˆå“ˆå¸Œä»¥é¿å…é”®è¿‡é•¿
        using var sha256 = SHA256.Create();
        var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(keyBuilder.ToString()));
        return Convert.ToBase64String(hashBytes);
    }
}

// æ‰¹é‡è¯·æ±‚ä¼˜åŒ–
public class BatchRequestOptimizer : IBatchRequestOptimizer
{
    private readonly Dictionary<string, List<BatchRequest>> _pendingRequests;
    private readonly Timer _batchTimer;
    
    public async Task<T> AddToBatchAsync<T>(string batchKey, Func<List<object>, Task<List<T>>> batchProcessor, object request)
    {
        var taskCompletionSource = new TaskCompletionSource<T>();
        
        var batchRequest = new BatchRequest
        {
            Request = request,
            CompletionSource = taskCompletionSource
        };
        
        if (!_pendingRequests.ContainsKey(batchKey))
        {
            _pendingRequests[batchKey] = new List<BatchRequest>();
        }
        
        _pendingRequests[batchKey].Add(batchRequest);
        
        // å¦‚æœæ‰¹æ¬¡å·²æ»¡æˆ–è¶…æ—¶ï¼Œç«‹å³å¤„ç†
        if (_pendingRequests[batchKey].Count >= 10)
        {
            await ProcessBatchAsync(batchKey, batchProcessor);
        }
        
        return await taskCompletionSource.Task;
    }
    
    private async Task ProcessBatchAsync<T>(string batchKey, Func<List<object>, Task<List<T>>> batchProcessor)
    {
        if (!_pendingRequests.TryGetValue(batchKey, out var requests) || requests.Count == 0)
            return;
            
        _pendingRequests[batchKey] = new List<BatchRequest>();
        
        try
        {
            var requestObjects = requests.Select(r => r.Request).ToList();
            var results = await batchProcessor(requestObjects);
            
            for (int i = 0; i < requests.Count && i < results.Count; i++)
            {
                ((TaskCompletionSource<T>)requests[i].CompletionSource).SetResult(results[i]);
            }
        }
        catch (Exception ex)
        {
            foreach (var request in requests)
            {
                request.CompletionSource.SetException(ex);
            }
        }
    }
}
```

---

*æœ¬AIé›†æˆæŒ‡å—ä¼šéšç€æ–°æŠ€æœ¯å’ŒæœåŠ¡çš„å¼•å…¥æŒç»­æ›´æ–°ã€‚*